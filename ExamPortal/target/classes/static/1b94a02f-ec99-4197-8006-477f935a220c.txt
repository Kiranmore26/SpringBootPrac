1991 ==> Oak
After that it has been rename with JAVA
company introduced ==> sun microsystem  => Oracle
james Gosling

SCJP =>SUN CERTIFIED JAVA PROGRAMMER
OCJP =>ORACLE CERTIFIED JAVA PROGRAMMER

Implementation of java :-
---------------------------
* Desktop Application
* Web Application
* Mobile Application
* Games(MultiThreading)

Types of Java :-
----------------------
J2SE  => Java Standard Edition(core java)
J2EE  => Java Enterprise Edition(adv java,servlets,JSP,EJBs(Entity Java Beans))
J2ME  => Java Mobile Edition

Language fundamentals 
-----------------------
Identifiers    J2SE , J2EE , J2ME
Resevered words
datatypes  

Identifiers 
-------------
Any name in java is called as an identifier.
whether it is a variable name 
class name 
method name 
literals name 

Rules for the identifier :
----------------------------
1)it only allows a-z,A-Z,0-9,$,_
public class Sybcafirstprog {

	public static void main(String[] args) {
	    int aaaaAAAZZZZ$=12;
		int %AAA#A_AA$A=10;  ==> invalid 
		System.out.println(AAAA_AA$A);

2)Identifier should not start with the digit 
---------------------------------------------
int 9aaa98888AAA=10; ==>invalid 

3)Java identifiers are case sensative 
----------------------------------------
	int A=10;
		System.out.println(A);
		
4)We cant use the reserved words as an identifier.
----------------------------------------------------
int class=10;
		System.out.println(class); ==>invalid 
	
5)There is no limits for the identifer length .
      no its not the recommended appoach 
	  
	int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=10;
		System.out.println(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
		
6)All the predefined class name and interface name we can use as an identifier 
---------------------------------------------------------------------------------
no its not recommended at all .
 int String =10;
		 System.out.println(String);  ===> valid 
		 
		 
Reserved words (53) :-
-----------------
it is of two types 
   1)keywords          (50)
   2)Reserved literals (3)
 
 when we talk about the functionally then it is associated with the keywords.
 If we dont talk about the functionality only values is req. then it is 
 reserved literals .(true,false,null)
 
 keyword for the datatypes (8)
 ----------------------------
 int,long,float,double,boolean,char,short ,byte

keywords for the flow control :-
----------------------------------
if,else,switch,case,default , while,do , for , break,continue, return 

Keywords for the modifier:-
-------------------------------
public , private,protected,static,final,abstract,synchonize,native,strictfp,trasient,volatile

Keywords for the class :-
-----------------------------
class ,inteface,extends ,implements,package,import

keywords for exception handling :-
---------------------------------
try , catch,throw,throws,finally,assert

goto,const:unused keywords
----------------------------
goto = switch
const -->final

enum keywords :-
------------------
enum month
{
 jan,feb,march,april.......
}

Datatypes
---------
Every variable in java should have some datatypes  
1) Numeric datatypes   (0-9)
2) Non - Numeric datatypes //true ,false

Numeric Data types (0-9)
------------------------
Byte :-
-----------          
size - 1 byte 
127 - 8 bits - 1 byte
-128 -----0 ----- 127 

Short Datatypes :-
-------------------
size is 2 bytes  means 16 bits 
range is -32768 - 32767

Int datatype :-
-----------------
4 byte - 32 bits 
Range is ==> -2147483648 to 2147483647

Long datatype:-
------------------
8 byte = 64 bits ==> 32 bits or 64 bits 

Intregal datatypes => byte , short,int,long

Float datatype:-
------------------
if we want the decimal format so we go throught hte float datatype 
single precision means the accuracy 

public class Sybcafirstprog {

	public static void main(String[] args) {
    float f = 10.5555555555555f;   == . o/p ==>10.555555 = 6 character 
   System.out.println(f);
   
Double datatype is called as double precision .
 public static void main(String[] args) {
    double f = 10.55555555555555555555555; 
   System.out.println(f);   o/p ==> 10.555555555555555 == > 15 character 
   
Example :-
----------
	public static void main(String[] args) {
    float f = 10f;
    float a = 3f;
    double b= f/a;
   System.out.println(b);
   
char datatype:-
-------------------
size is 2 bytes
char a ='a';

In c Prog ===> Ascii
In java =====> unicode 

Literals :-
---------------
int x =10;
Tyeps of literals :-
1)decimal literals :-
----------------
base - 10 allowed digits are (0-9)
Example :-
int x =10;
2)Octal form :-
----------------
base - 8 allowed digitws are (0-7)
int x =010;

3)Hexa Decimal:-
-----------------
base - 16 allowed character are 
           0-9
		   A-F
		   a-f
Example :-
----------
	int x =0xabcd;
		System.out.println(x);
		
4)Binary literals :-
------------------------
base 2 aloowed digits are 0 and 1 only 
Example:-
------------
int x =0b010;
System.out.println(x);
  
Escape characters 
--------------------
\n =>new line 
\t =>horizontal tab 
\r =>carriage return
\b =>back space
\f =>form feed 
\  =>single quotes
\\ =>comments

Unicode code :-
---------------------
	
		double d=1_1_1_1.5_5;
		System.out.println(d);
		
Array :-
-----------
Topics to be covered :=
-------------------------
Introduction
-----------------
Heterogeous ===> No arraays are not heterogeous .
Arrays are homogeous in nature .

Array Declaration:-
------------------------
1-D Array
------------
int []x;
int[] x;
int x[];

2-D Array
-----------
int [][]x;
int x[][];
int []x[];
int []       []x;
int [] x[];

int x[] = new int[10]; ==> to crreate the object in array 

3 D Array :0-
------------
int x[][][];

Array Creation :-
-----------------
String [] s = {"abc,"def","lmn","xyz"} o/p==>Ljava.lang.String;@6d06d69c ==> hashcode 

Examples:
-----------
class Java3
{
	
public static void main(String[] args) {
	int a[]= {10,20,30,40,50};
	for (int i=0;i<5;i++)
	{
		System.out.println("element at " +i+" index is :" + a[i]);
	}
}
Array initialization
---------------------
How to assign the variables 
int [] a = {10,20,30,40}
char ch={'a','b'}

Object 0[]=new Object[12];
Integer i[] = new Integer[];

Conclude:-
--------------
Array are fixed in size .
Collection --> vector class, ArrayList class ,Map Class 
Array are heterogeous when we are going through the class or object concept 
If we are using the primitive data then araays are homogenious .

Length vs Length()
------------------
Length variable is used with the array and it is used to return the lenght of the array 
Lenght() is used with the data types like string 

How many type of array :-
----------------------------
primitive array :-
--------------------
int a[]={10,20,30};  
Elements allowed ==> We can insert only the integer values 

Object type of array :-
---------------------------
Number n []= new Number []; 
Elements allowed  ===> Any object we can take 





Types of variable :-
------------------------
int a = 10 
Based on the type of value represented by the variable by the variable 
all variables are divided into 2 types :

1)Primitive Variable 
2)Reference Variable or Object 

1)Primitive Variable :-
------------------------
It is used to represent primitive values.
Example :-
-----------
    int a= 10 ;

2)Reference Variable :-
-------------------------
It is used to refer the object .
Example :-
----------
  Student s = new Student();
  
Based on the position of declaration and behaviour all variables are
 divided into 3 types :-
1)Instance Variable or global variable 
2)Static Variable
3)Local Variable 

1)Instance Variable:-
------------------------
*If a value of a variable is varied from object to object such type of 
variable are called as Instance variable.
*For every object a seperate copy of instance variable will be created.
*Instance variable should be declared within the class directly but outside
 of any method , block,constructor.
 Example:-
 -----------
 class Test
 { 
   int a=10;
 }
*Instance variable will be created at the time of object creation and destroyed
 at the time of object destruction .
*Instance variable will be stored in the heap memory as a part of object.

Example:-
-----------
public class Secondjavaclass {
	int x=10;

	public static void main(String[] args) {
		//System.out.println(x);C.E=>because main method is static no where related to object.Cannot make a static reference to the non-static field
		Secondjavaclass s= new Secondjavaclass(); //and instance variable is part of object 
		System.out.println(s.x);// valid=>we cant access the instance variable directly from static 
		                                //area but we can access by using the object reference 
        public void m1()
	{
		System.out.println(x); //valid => we can accesss instance variable directly from the instance area.
	}
}

* For the instance variable JVM will always provide the default value.
Example:-
----------
class Test
{  
    int x;
	double d;
	long y;
	boolean b;
	String s;
	public static void main(String[] args) {
		Secondjavaclass s = new Secondjavaclass();
		System.out.println(s.x);
		System.out.println(s.d);
		System.out.println(s.y);
		System.out.println(s.b);
		System.out.println(s.s);
}

conclusions:-
---------------
# If the value of the variable is not varied fron object to object then it is not 
  recommended to declare that variable as instance variable,we have to declare such type 
  of variable by using the static modifier.
# In case of instance variable for every object a seperate copy will be created but in case 
  of static variable a single copy will be created and shared by every object of that class.
  
 
========================================

 Static variables:-
 --------------------
 * It should be declared within the class directly but outside any method , block and 
   constructor .
 * static variable will be created at the time of object creation and destroyed
   at the time of object destruction .
 * static variable will be stored in the method area(just like the heap) as a part of object.
   local variabole are stored in the stack area.
 * we can access static variable either by object or reference variable or class name .  
 Example :-
 ---------------
 public class DemoD {
	static int x = 10;
	public static void main(String[] args) {
		DemoD d = new DemoD();
		System.out.println(d.x);  // valid 
		System.out.println(DemoD.x);// valid
		System.out.println(x); // valid
	}
	
 * we can access static variable directly from both instance and static area .
 
 Example :-
 --------------
 public class DemoD {
	static int x = 10;
	public static void main(String[] args) {
		DemoD d = new DemoD();
		System.out.println(x);
		d.m1();
	}
     public void m1() {
    	 System.out.println(x);
     }
	}

 * For static variables JVM will provide the default values and we are not 
   required to perform initialkization Explicitly.
   
 Example :-
 -----------
 public class DemoD {
	static int x ;
	static float f;
	static String s ;
	static boolean b ;
	public static void main(String[] args) {
		System.out.println(x);
		System.out.println(f);
		System.out.println(s);
		System.out.println(b);
	}
	
Local Variables :-
---------------------
 * The variables which are declared inside the method,block,or constructor such type
   of variable is known as Local variable.
 * Scope of the local variable is the block in which we declare it .
 * for local variable JVM wont provide the default values.
 * local variable are stored inside the stack memory .
 
 Var - arg Method :-(1.5 version )
 ----------------------
 variable no of augumnets
 any values we can pass in the method arguments 
 Internally var arg method uses the 1 D array approach 
 int x[];
 
 
 Operators in Java:-
 -----------
 + =>add two nos . for the concatination ,-,*
  hello + how r u 
  
 About main method :-
 ----------------------
 1)final 
 2)syncronize
 3)strictfp
 
 these are the only modifier we can add inside the mnain method .
 
 Increment and decrement operator :-
 --------------------------------------
 It is of two types :-
 ---------------------------
 pre-increment ==>++x
 post increment ==>x++
 public class FirstBCA_B {

	public static void main(String[] args) {
	
	int x = 10;
	int y=--x;
	System.out.println("the value of y is " +y);
	System.out.println("the value of x is " +x);
	}

	max(10,20)===>20
 
 
public class FirstBCA_B {
     
	void sum(int ...x)
	{
		int total = 0 ;
		for (int x1:x)
		{
			total=total+x1;
		}
		System.out.println("addtion of the given no is " + total);
		
	}
	public static void main(String[] args) {
	 FirstBCA_B f= new FirstBCA_B();
	 f.sum(10,20);
	}  

}

 

 Arithmetic operator :-
 ------------------------
 (+,-,*,/,%)
 +  ==>
 we can apply A.O between two variables like a and b and the result is max(int ,type of a , type of b)
 byte+byte= int
 byte+short=int
 short+short=int
 byte+long= max(int,byte,long)==> long
 long+double=double
 char+char=int
 char+double =double      max (int , char , double)
 Examples :-
 -------------`
 public class FirstBCA_B {

	
	
	 public  static void  main(String... args) // inside the JVM 
	{
       System.out.println('a'+'b');//97 and 98 ==195
	     System.out.println('a'+ 0.01);
	}
}
/ ==> division.
public class FirstBCA_B {

	
	
	 public  static void  main(String... args) // inside the JVM 
	{
       System.out.println(10/0.0);//infinity
       System.out.println(10/0); //exception 
       System.out.println(0.0/0);//NaN ==> not a number
	}
 
 String concatination :-
 -------------------------
 (+) overloaded operator in java
 public class FirstBCA_B {
	 public  static void  main(String... args) // inside the JVM 
	{
     String c = "BCA";
     int a = 10 ;
     int b= 20;
	 int d = 30 ;
     System.out.println(a+b+c);//left to right 
     System.out.println(b+d+a);//
	}
}
1) Concatination ==> if atlaest one argument is string type then it performs the concatinations
2) Addition


Relational operator :-
------------------------
(<,<=,>,>=)
we can apply relational operator only for the primitive data types except booleans .
For the object we cannot use the relational operators .
Nesting of the relational operator is not allowed .

Equality operators :-
----------------------------
(==,!=)
* we can apply Equality operators  for the primitive data types and the  booleans as well .
* Eqality operators can be applied for the object types as well .

Example :-
public class FirstBCA_B {
	 public  static void  main(String... args) // inside the JVM 
	{

   System.out.println(true==false);
   String s = new String("abc");
   String s1 = new String("abc");
   System.out.println(s==s1);
      
	}
* Equality operator is meant for the reference comparision .

Example :-

public class FirstBCA_B {
	 public  static void  main(String... args) // inside the JVM 
	{

  // System.out.println(true==false);
   String s = new String("abc");
   String s1 = new String("abc");
   String s3=s;
   System.out.println(s==s1);
   System.out.println(s3==s);
   }
   }
  
 vvi Difference between == operator and .equals operator .
 ------------------------------------------------------
 == Operator is meant for the reference comparision 
 whereas .equals is meant for the content comparision.
 example :-
 --------------
 public class FirstBCA_B {
	 public  static void  main(String... args) // inside the JVM 
	{
      
      String s1="abc";//null  ==> non primitive 
      String s2 = null;
     // System.out.println(s1==s2);
      System.out.println(s1==s2);//false
      System.out.println(s1.equals(s2)); 
     
	}
}
 
 Instanceof Operator :-
 -------------------------
 instanceof
 It is use to check whether the given object is a particular type or not.
 Example : - 
 -----------------
 public class FirstBCA_B {
	 public  static void  main(String... args) // inside the JVM 
	{
      String s = "abc";
      Thread t = new Thread();
      
      System.out.println(s instanceof Object);// true
      System.out.println(t instanceof Object);//true
      System.out.println(s instanceof Thread);//CE : inconvertable type
     
	}
}

Bitwise Operator :-
-------------------
(&,^,|)         7 &8 ==>
we can apply for the boolean as well as the intregal datatypes 

& ==> AND Operator Rerturns true iff both arguments are true.
| ==> OR Operator  Returns True iff atlaest one argument is true .
^ ==> X-OR Operator Returns true iff both the arguments are different .

Examples :-
-----------
public class FirstBCA_B {
	 public  static void  main(String... args) // inside the JVM 
	{
     System.out.println(true&true);//true
     System.out.println(true|false);//true
     System.out.println(true^true);//false
     System.out.println(4&5);// 4
	}
}

Bitwise Component Operator :-
---------------------------------
~ 2 s complement 
this operator are applied only for the intregal type. this is not applied for the boolean type.
sop(~true)==> ce
sop(~4) 100 ==> 3 bits 32 bits 10000000000000000000100
          1                                          1
	-----------
	    101  ==> 5 3 bits
		
Boolean Compliment Operator (!):-
---------------------------------
We can apply this operator for the boolean type not for the intregal types .
System.out.println(!true);==>false
System.out.println(!4);==> 100
                           011 3 o/p error ==>>The operator ! is undefined for the argument type(s) int
						   

 Short - curcuit operator :-
 --------------------------------
 (&&,||) 
 || ==>  Returns True iff atlaest one argument is true .
 System.out.println(false  || false);
 && ==>  Returns true iff both arguments are true.
 System.out.println(true  && true)
 
 & and |
 
 if (a1 & a2)  for checking this a1==5 mins   a2 ==5 mins 2mins ==12 mins 
 {
 if (a1 && a2) 5mins 2 mins ==>7 mins                           
Difference between &,| and &&,|| :-
----------------------------------------
        & , |                          &&,||
 -------------------------------------------------------------------------
 1)Both arguments are verified       Second argument is optional
 2)Performance is low                Performance is High .
 3)Apply for boolean and Intregals   Applicable for only boolean not for intregal.
 
 Example :-
 ---------------                       operator     X Value    Y Value 
 int x= 10;                           ------------------------------------
 int y= 15;
 if (++x<10 && ++y>15)                   &           11         17 
 {    false &&    false
  x++                                   |            12         16  
 }
 else                                   &&           11          16
 {
  y++                                   ||           12          16 
 }
 
 
 Program :-
 --------------
 public class FirstBCA_B {
	 public  static void  main(String... args) // inside the JVM 
	{
            int x = 10;
            int y = 15;
            if (++x<10 || ++y>15)
            {
            	x++;
            }
            else
            {
             y++;
            }
            System.out.println(x +"......"+ y);
		 
		 
	}
}
 
Type-Cast Operator :-
------------------------
1)Implicit Type casting / Upcasting
2)Explicit Type casting /Downcasting

1)Implicit Type casting :-
------------------------------
JVM is going to perform the job 
widening
keeping small values in the big container is known as implicit typecasting ,widening , upcasting .
here we can assign smaller datatypes variables to bigger datatype variable  
 //  long a= 10.5f;
       float f = 10000000000l;
       double d = 10.5f;
       System.out.println("hello");
       float r = 10.5;// error 
       System.out.println("the value of long data type");
	   
2)Explicit Type casting /Downcasting
-----------------------------------------
int a = 10l;// cannot convert from long to int 
If i want to insert bigger values to the smaller one 
then this concept is known as Explicit type casting
Here we might loss the data .
If the requirement is there then go for the explicit typecasting.
Its not the recommended approach.
example :-
-----------------
when ever u r taking the input fron the user by default it is string type 

string int 1 lakhs ==>performance // slow process 
add two nos.
with 

Naming convensions :-
--------------------
isLetter() :-
hungarian notation :-
----------------------
first alphabet of any letter will start with small letter and secong with the capital letter 

compare()
compareTo()
addSum() ==> this is known as hungarian notation 

camel case notation :-
---------------------------
rajuRajAsthanaGupta () : 
isUpperCase
class name always start with capital leeter ===>> class 

instanceof // method 

Assignment Operator :-
-----------------------
int x = 10;
We are having 3 types of assignment operator :-
--------------------------------------------------
1)Simple assignment operator (=)
Example :
----------
int x = 10;
2)chained assignment operator 
 a=b=c=d=10;
 Examples :-
 ------------
 	int x = 130;//simple assignment operator
	String a,b,c,d,e;//
	a=b=c=d=e="QuickXpert ";//chained assignment operator 
	System.out.println(a+"..."+b +"..."+c);
 
 
 
3)compound assignment operator
----------------------------------
Assignment operator mixed with  some other operator 
+=
-=
*=
/=
%=
&=
|=
^=
>>= //Right shift operator            x=10101010
                                 x>>2   11101010// after right shifting we are going to get 
								 x>>>=2 00101010                  two empty bits signed 
>>>= valid//unsigned right shift operator 
<<=
<<<= //invalid 

Special case of assignment operator :-
------------------------------------------
Example 1 :-
-------------
 byte b =10;
     b=b+1;//max(byte,byte,int )
     System.out.println(b);//o/p=>
	 
	 
Example 2 :-
-----------
  byte b =10;
    b=++b;// b=(byte)(b+1)
     System.out.println(b);//o/p=>11
	 
Example 3:-
---------
 byte b =10;
    b +=10;// b=(byte)(b+10)
     System.out.println(b);//o/p=>20
	 
Example 4 :-
----------------
 byte b = 125;
		 b += 5;
		 System.out.println(b);//130
		 
Example 5:-
---------------
int a,b,c,d;
	a=b=c=d=20;
	a += b -= c *= d /=2; //right to left 
	System.out.println(a+"..."+b+"...+"+c+"..."+d);
   
   // d=10 , c=200, b = -180 , -160

Ternary Operator :-
--------------------
  (? :)
  int x =(10<20)?30 :40
 
Example :-
-----------
 int x =(10>20)?19:20;
 System.out.println(x);
Example 2 :-
--------------
 int x =(10>20)?19:((40>50)?50:70);//chaining in the ternary operator 
 System.out.println(x);
-------------------------------
new operator :-
-------------------
new operator is used to create the object.
Demo d = new Demo();
1)constuctor is used to create the object. //invalid 
2)constructor are used to initialize the object .//valid 

[] operator :-
-------------------
We can use this operator in order to create or declare the array .
Example :-
----------
int [] x = new int [10];

Operator precedence :-
----------------------------
uninary Operator  => One Arguments //++x,--x
binary operator   => Two Arguments //a+b
ternary operator  => Three Arguments //(10<20)?30 :40

Highest priority is given to =>Uninary Operator > Binary Operator > Ternary operator 
Least Priority is given to the assignment operator .(=,+=,-+,*=)

Operator Precidence :-
----------------------------
1)Uninary operastor :
    [],x++,x--  =>1st
	++x,--x,~,! =>2nd
	new,<type>  =>3rd

2)Arithmetic operator :-
-----------------------------
     *,/ ,%    
	 +,-
3)Shift operator :-
------------------------
     >> ,>>>,<<
	 
4)comparision operator :-
----------------------------
     <,<=,>,>=,instanceof 
5)Equality operator :-
-----------------------------
     == ,!=
6)Bitwise operator :-
-----------------------------
   &
   ^
   |
7)Short circuit operator :-
------------------------------
   &&
   ||
   
8)Conditional operator :-
------------------------------
   ?:
9)Assignment Operator :-
-------------------------------
    =,+=,-=,*=,/=
	


10*20/30%40
Evaluation order of java Operands :-
---------------------------------------
It will always go through left to right .

new VS newInstance():
-------------------------
Demo d = new Demo();
Both are used to create the Object.
But In some cases we are not able to create the object with the help of new operator .
We can use newInstance() to create the object if we dont know class name in the beginning at it is 
available dynamically at runtime .
new Instance() is present in class "Class".java.lang.Class 
In real time newInstance () is used by the servlet to create the Object .

newInstance() internally calls no-arg constructor hence to use newInstance() compulsory the class 
should contain no arg constructor otherwise we are going to get the runtime Exception .
b
newInstance() is always going to throw the exception .
 
 Example :-
 --------------
 class DemoInstance
{}
class Demo10
{}
public class NewInstanceDemo 
{ 
    public static void m1(String c)  throws Exception
    { 
        //Object o = new Object();
        Object obj = Class.forName(c).newInstance(); 
        System.out.println("Object created for class is:"
                        + obj.getClass().getName()); 
    } 
    public static void main(String[] args) throws Exception 
    { 
    m1("Demo10"); 
    m1("java.lang.String");
    m1("java.lang.Object");
    
    }    
}
instanceof VS isInstance() :-
------------------------------
isInstance():
----------------
It is present in java.lang.Class.
We can use isInstance() to check whether the given object is of particulat type or not,
and we dont know the type at the beginning and it is available dynamically at runtime .


Flow control :-
------------------
Flow control describes the order in which the statement will be executed at runtime.

Three types of flow control :
--------------------------------
1)selection statement :-
---------------------------
     a)if-else 
	 b)switch ()

2)Iterative Statements :-
-----------------------------
     a)while loop
     b)do-while
     c)for()
     d)for-each loop 
3)Transfer statement :-
--------------------------
     a)break
     b)continue
     c)return
     d)try-catch-finally  //exception handling
     e)assert statement  // assertion 

1)Selection statement :
-------------------------------
IF-ELSE	:-
---------------
  Syntax :-
---------------
         
      if (b)      // b should be  boolean type  
         { 
		   if b is true then perform this action 
		 }	  
      else
	  {
	      if b is false then perform else action 
	  }

Example:-
----------
class Demo
{
	public static void main(String[] args) {
		int x =0; //false
		if (x)
		{
			System.out.println("this is if block" );
		}
		else 
		{
			System.out.println("this is else part ");
		}
		
	}
	}

Example 2 :-
-----------------
class Demo
{
	public static void main(String[] args) {
		int x =10; //false
		if (x=10)//true
		{
			System.out.println("this is if block" );
		}
		else 
		{
			System.out.println("this is else part ");
		}
		
	}
	}
Example 3:-
---------------
class Demo
{
	public static void main(String[] args) {
		int x =10; //false
		if (x==10)//true
		{
			System.out.println("this is if block" );
		}
		else 
		{
			System.out.println("this is else part ");
		}
		
	}
	}

special cases :-
-------------------
if we are not taking any curly bracket we can take only one statement 
but that statement should not be a declative statement .

Example :-
----------
if(true )
int x =10;



==============================================
int x =0;     0 == false 1 ==true
if (x)
  print("this is if block ")
else 
print(("this is else block ")

o/p  : 
----
syntax:-

if(b)       ====> this b should always be of boolean type
{
  if this is true then if statement wil be execute 
}
else 
{
  if condition is false then else part will be executed .
}

special cases :-
------------------------
if (true) 
 int x = 10; o/p ==> blank output , 1 ,
 
if (true)
   if (true)
     print("this is nestred if block ")
else 
     print("this is else block ")
	 
else 
print("anything ")
	 
if any else is there it will always point to the neareast if .
Example :
   if (true)
    	  if (20<10)
    		  System.out.println("if block ");
    	  else 
    		  System.out.println("else part ");
			  
Switch Statement :-
--------------------
If suppose we are having multiple conditional statements then
it is not recommended to go for the if else statement .
Syntax :
------------
   int x =10;  
   switch (x)                 where x should be byte , short ,char,int 
                                            not allowed long , double ,float  valid till java 1.4 version 
     {                            In java 1.5 version Wrapper classes are allowed .
	   case 1: Action 1              no string are not allowed till java version 1.6 version 
	           break ;                but from java 1.7 version onwards Strings are allowed .
	   case 2: Action 2 
	           break;
	   Default: Default action 
	 }
	 
Is Curly bracket complusory : 
--------------------------------
Yes Curly bracket is mandatory .

Case 1 :  we cannot take variable constant in the switch case .
---------
Example : 
 {
         int x =30 ;
         char y ='a';
         switch (x)
         { 
         case 1:
        	 System.out.println("case 1");
         case y :
        	 System.out.println("case 2 ");
           
         } 
		 
		 
              int x =10;
			  switch(s)
			  {
			 
			 
			 print("thisa si hello to everyone ")
			 
			 
			 }
Switch case examples :-
-------------------------
int day = 1

switch (day) {
  case 1:
    System.out.println("Monday");
    break;
  case 2:
    System.out.println("Tuesday");
    break;
  case 3:
    System.out.println("Wednesday");
    break;
  case 4:
    System.out.println("Thursday");
    break;
  case 5:
    System.out.println("Friday");
    break;
  case 6:
    System.out.println("Saturday");
    break;
  case 7:
    System.out.println("Sunday");
    break;
} 

Case 1 :
----------- 
byte  day = 4;
switch (day) {
  case 10:
    System.out.println("Monday");
    break;
  case 200:
    System.out.println("Tuesday");
    break;
  case 3000:
    System.out.println("Wednesday");
    break;

} // Invalid 
case 2:
----------

byte  day = 4;
switch (day+1) {
  case 10:
    System.out.println("Monday");
    break;
  case 200:
    System.out.println("Tuesday");
    break;
  case 3000:
    System.out.println("Wednesday");
    break;

} //valid 

case 3 :
----------
int   day = 4;
switch (day) {
  case 97:
    System.out.println("Monday");
    break;
  case 98:
    System.out.println("Tuesday");
    break;
  case 'a':
    System.out.println("Wednesday");
    break;
} // Invalid because duplicate cases are not allowed 

case 4 :
---------
Fall through in switch case .
--------------------------------
int day = 4;
switch (day) {
  case 1:                                             
  case 2:
  case 3:
    System.out.println("thisd is q1");
	break ;
  case 4:
  case 5:
  case 6:
    System.out.println("this is q2");
    break;
  case 7:
    System.out.println("Sunday");
    break;
} 
			  
Assignments :-
---------------------
 
Q 1) Write a Java program to check whether a number is divisible by 5 or 11 or not. 
	   
	  
Q 2) Write a Java program to input marks of five subjects Physics, Chemistry, Biology, Mathematics and Computer. 
     Calculate percentage and grade according to following:
     Percentage >= 90% : Grade A
     Percentage >= 80% : Grade B
     Percentage >= 70% : Grade C
     Percentage >= 60% : Grade D
     Percentage >= 40% : Grade E
     Percentage < 40%  : Grade F    
	 
Q3 ) Write a Java program to input any alphabet and check whether it is vowel or consonant. 
      a,e,i,o,u ==> this is a vowel 
	  
Q 4) Write a Java program to make  Calculator using the switch statement.
      +,-,*,%,/,^,&
Q 5) Write a Java program to check if an integer is odd or even using ternary operator.
       (?   :)

Q 6 ) Is New Keyword or a  method Name ?
       

For loop :-
-----------
syntax :
-----------
for (statement 1; statement 2; statement 3) {


  // code block to be executed
}

Example :-
-------------
for (int i = 0; i < 5; i++) {
  System.out.println(i);
}
      
	  
While loop :-
---------------
Syntax :-
----------
while (condition) {      where condition should be always boolean type 
  //code block to be executed
}

Example :-
------------
int i = 0;
while (i < 5) {
  System.out.println(i);
  i++;
} 
case 1  :-
-------
while (1)
 {
    System.out.println("hello ");
 }
 we will get C.E because 1 is treated as int type .
 
case 2:
---------
while (true)                            //valid 
  System.out.println("hello ");
  
while (true);                           //valid 

while (true )                          //Invalid 
     int a =10;
    
while (true )                          
 {
    int a = 10 ;
 }

case 3 :-
-------------
while (true)                                  // Invalid            
{
  System.out.println("hello ");
}
System.out.println("Out of this loop  ");     Unreachable statement 

example 2:-
--------------

while (false)                                  // Invalid            
{
  System.out.println("hello ");               // Unreachable statement 
}
System.out.println("Out of this loop  ");

Example 3 :-
----------------
int a = 30;                                
int b = 20;
while (a<b)
 {
  System.out.println("hello ");
 }
 System.out.println("out of this loop  ");

example 4 :-
-------------
        final int a = 10;                                
		final  int b = 20;
		 while (a<b)
		  {
		   System.out.println("hello ");
		  }
		  System.out.println("out of this loop  ");
		 
		 
		 
final keyword :-
----------------------
Every final variable we be replaced by the value at compile time only ,
it is not waiting for the runtime because its value is fixed .

Example :-
--------------
       final int a = 10;
	   int b = 20;
	   System.out.println(a); //    10 
	   System.out.println(b); //    b

Do - While loop :-
-------------------
Sysntax :-
----------------
do {
  // code block to be executed
}
while (condition);

case 1:-
-----------
do                                           // valid 

 System.out.println("hello ");    
 
while (true);


do ;                                       //  valid 
while (true); 

do                                        //invalid 
 int a =10;
while (true )

do
{
   int a =10;      // valid 
}
while (true)

do                           Invalid do statement always requires a body 

while (true ) ;     //  

Break statement using the scanner class :-
=----------------------------------------------

 int day ;
	   Scanner sc = new Scanner(System.in); 
	   System.out.println("enter the value between 1 to 7  : "); //1,2,3,4,5,6,7,8,10,
       day = sc.nextInt();
	   

			   switch (day) {
			     case 1:
			       System.out.println("Monday");
			       break;
			     case 2:
			       System.out.println("Tuesday");
			       break;
			       
			     case 3:
			       System.out.println("Wednesday");
			     case 4:
			       System.out.println("Thursday");
			       break;
			     case 5:
			       System.out.println("Friday");
			       break;
			     case 6:
			       System.out.println("Saturday");
			       break;
			     case 7:
			       System.out.println("Sunday");
			       break;
				   
				 default:
				     System.out.println("Enter proper input");  
			   } 
}	        

for - each loop :-
-----------------------
Is also known as enhanced for loop 
It is specially designed to retrive the data from the array or collections.

int [] x = {10,20,30,40,50}

Example using normal for loop :-
---------------------------------
 int [] x = {10,20,30,40,50};
		 for(int i =0; i<x.length ; i++)
		 {
			 System.out.println(x[i]);
		 }
		 
Example using for - each loop :-
------------------------------------
 int [] x = {10,20,30,40,50,60};
		
		 for(int x1 : x)
		 {
			 System.out.println(x1);
		 }
		 
Example using 2D array :-
---------------------------
 int [][] x = {{10,20,30},{100,200,300}};
 for (int i =0; i< x.length ; i++)
		 {
			for (int y = 0; y < x[1].length ; y++)
			{
				System.out.println(x[i][y]);

		 }
		
		 }
 
 Example using for each  loop :-
 ---------------------------------
int [][] x = {{10,20,30},{100,200,300}}; 
 for (int [] x1 :x)
		  {
			  for (int x2 :x1)
			  {
				  System.out.println(x2);
			  }
			  }
 

 various case of for loop :-
 ---------------------------------------
 for (initiazation_secton ; conditional_checking , increment/decrement)
    {       1                   2,5                        4,7
	
	  loop body -3,6  
	}

	
case 1 :-
----------
int i = 0 ;
for (System.out.println("this is initialization "); i<3 ; i++)

{
    System.out.println("body loop ");
}

case 2:-
---------
int i = 0 ;
for (System.out.println("this is initialization ") ; ;i++)

{
    System.out.println("body loop ");
}

case 3 :-
---------
int i = 0 ;
for (System.out.println("this is initialization ") ;i<3 ;System.out.println("this is increment section ") )

{
  i++ ;
}

conclude:-
---------------
All the three part s of the for loop is independent of each other and optional .
for (; ; )
	{
	  System.out.println("infinite loop ");	
	}
	}

case 1 :-
------------
for (int i = 0 ; true ; i++)
{
     System.out.println("body loop  ");
}
System.out.println("out of body loop  ");


case 2:-
----------
for (int i = 0 ; false ; i++)
{
     System.out.println("body loop  ");
}
System.out.println("out of body loop  ");

case 3 :-
-----------
for (int i = 0 ; ; i++)
{
     System.out.println("body loop  ");
}
System.out.println("out of body loop  ");

case 4 :-
--------------
int a = 10 ,b=20;
for (int i =0 ; a>b ;i++)
{
     System.out.println("body loop  ");
}
System.out.println("out of body loop  ");

case 5:-
---------
	final int a = 30 ,b=20;
		for (int i =0 ; a<b ;i++)
		{
		     System.out.println("body loop  ");
		}
		System.out.println("out of body loop  ");
	}

 
 Break statement :-
 --------------------
 int [] a= {10,20,30,40,50};
 for (int x : a)
 {
    if (x==40)
	{
	  break;
	}
	System.out.println(x);
 
 }
continue Statement Example :-
-------------------------------
 int [] a= {10,20,30,40,50};
 for (int x : a)
 {
    if (x==40)
	{
	  continue;
	}
	System.out.println(x);
 
 }
 
Return statement example :-
-----------------------------
 
 class Demo
{
	public int   add(int x , int y)
	{
		
		
		return  x+y;
	}
	public static void main(String[] args) {
	
		Demo d = new Demo();
		int ad=d.add(100,200);
		System.out.println("the sum of the no is :" + ad)
 

 Transfer statement using try catch block :-
 ----------------------------------------------
 System.out.println("heloo");
	   System.out.println("hi");
	   try {
	   System.out.println(10/0);
	   }
	   catch (Exception e) {
		System.out.println(e);
	}
	   System.out.println("this is 4th statement ");
	   System.out.println("tjis is 5th statement ");
	   System.out.println("this is 6th statement ");
		 
		   }	
	
 ---------------------------------------------------------------------------
 
 String :-
 ---------------
 java.lang package
 
 Once we create a string object we cant perform any changes in the existing object .If we 
 are trying to perform any changes then a new object will be created .
 This non changeable behaviour is known as immutability of the string .
 
 Note :-
 --------
 In string class .equals() is an overloaded method for the content comparision.
 
 Example :-
 -----------
 	String s1 = new String("abc");
	String s2 = new String("abc");
	System.out.println(s1.equals(s2)); // true 
	
case 3:-
-----------
We can create the string object in 2 ways :-

1)By using the new keyword :-
--------------------------------
If we are using the new keyword then 2 objects it is going to create .
String s1 = new String("def");// 2 objects

1st object will be created in heap area
2 nd object is created in SCP(String constant pool area )

2)By using the String Literal :-
-------------------------------------
If we are using the string literals then only one object is going to be created in the scp area .
String s ="abc";
Only one object got created in the SCP area.
GArbage collector is allowed to access only the heap area .

Example :-
-----------
     String s1=new String("abc");
     String s2 = new String("abc");
     String s3 = "abc";
     String s4 = "abc";
     System.out.println(s1.equals(s2));
     System.out.println(s2.equals(s3));
	 
Example :-
---------
    String s1 = new String("abc");  // 2 objects created 
    String s2 = new String ("abc");
    String s3 = "abc";
    String s4 = "abc ";
	
Example :-
-----------
	
     String s1= new String("sahyog");
     s1.concat("college");
     String s2 = s1.concat("thane");
     s1=s1.concat("mumbai");
     System.out.println(s1);//
     System.out.println(s2);//
	
Constructors :-
----------------
1) String s = new String(); // Creates a empty String object 
2) String s = new String ("abc"); It creates a string literals with some argument under heap area .
3) String s = new String(StringBuffer sb);
4) String s = new String(char[] ch);
     Example :-
	 -----------
	char [] ch = {'a','b','c'};
    String s = new String(ch);
    System.out.println(s);
	
5) String s = new String(byte[] b);
     Example :-
	 -----------
	 byte [] ch = {101,102,103};
    String s = new String(ch);
    System.out.println(s);
  
Methods of Strings Class :-
---------------------------
1) public char charAt(int Index)
   Example :-
----------------
    String s = new String("abcdef");
    System.out.println(s.charAt(0));//a
    System.out.println(s.charAt(1));   //b
2)public String concat(String s )
    Example :-
	------------
	 String s1= new String("sahyog");
     s1.concat("college");
     String s2 = s1.concat("thane");
     s1=s1.concat("mumbai");
     System.out.println(s1);//
     System.out.println(s2);//
 
 
 3)public boolean equals(Object O)
 
       String s = new String("java");
       System.out.println(s.equals("Java"));//false
       System.out.println(s.equalsIgnoreCase("JAVA"));//true 
       
 
 4)public String subString(int begin index)
    Example :-
	---------
	 String s = new String("java is a programming lang");
     System.out.println(s.substring(8,15)); 
	 
Example :-
---------------
    String s = "java is a PROGRAMMING Lang";
    System.out.println(s.length());
    System.out.println(s);
    System.out.println(s.trim());
    System.out.println(s.toUpperCase());
    System.out.println(s.toLowerCase());
    System.out.println(s.replace('a', 'z'));
    System.out.println(s.indexOf('a'));
    System.out.println(s.lastIndexOf('a'));
 
 eXAMPLE :-
 ----------------
    String s1 = new String("abcdef");
    String s2 = s1.toUpperCase();
    String s3 = s1 .toLowerCase();
    System.out.println(s1==s2);
    System.out.println(s1==s3);

Example :-
---------------
    String s1 = new String("abc");
    String s2 = s1.toUpperCase();
    String s3 = s1.toLowerCase();
    System.out.println(s1.equalsIgnoreCase(s2));//true
    System.out.println(s1.equals(s3));// true 
    

StringBuffer Class :-
--------------------------
 student name     : String          //Bhavesh patil      cv 101..    9875656644
 student roll no  :  
 student phone no : 
 
 StringBuffer (synchonized):-
 ---------------------
 
Constructor of StringBuffer :-
 ----------------------------
1)StringBuffer sb = new StringBuffer();
It is going to create a empty StringBuffer object with 
the initial size 1 or capacity as 16 .
 
 Example 1 :-
 ------------
  StringBuffer sb = new StringBuffer();
  sb.append("aaaaaaaaaaaaaaaaaa");
  System.out.println(sb);
  System.out.println(sb.capacity());//16
  
 new capacity = (current capacity + 1 ) * 2 
              =  (16 + 1 ) * 2 
              =  17 * 2 
              =  34 			  
 
 example 2 :-
 -------------
 StringBuffer sb = new StringBuffer(); //16
  System.out.println(sb.capacity());
  sb.append("abc");
  System.out.println(sb.capacity());
  sb.append("aaaaaaaaaaaaaaaaaaaaaa");
  System.out.println(sb.capacity());
  sb.append("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaddddd");
  System.out.println(sb.capacity());
  sb.append("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
  System.out.println(sb.capacity());
 
2)StringBuffer sb = new StringBuffer(int initial capacity )
  System.out.println(sb.capacity());
ERxample :-
------------
  StringBuffer sb = new StringBuffer(100);
   System.out.println(sb.capacity());

3)StringBuffer sb = new StringBuffer(String s)
   capacity = s.length()+16
 
Example :-
------------
    StringBuffer sb = new StringBuffer("Sahyog");
    sb.append("college");
    System.out.println(sb.capacity());
 
 
Example :-
----------
  StringBuffer sb = new StringBuffer("abcdef");
   System.out.println(sb.capacity());//22
   sb.append("abcdefghijklmnopqrstuvwxyz");
   System.out.println(sb.length());//
   String s ="abcdef";
   System.out.println(s.length());
   
   
Methods of StringBuffer :-
--------------------------------
1)public char charAt(int index)

Example :-
-----------
    StringBuffer sb = new StringBuffer("Sahyog");
    System.out.println(sb.charAt(3));
	
2)public void setCharAt(int index , char ch )
 
    StringBuffer sb = new StringBuffer("Sahyog");
    System.out.println(sb.reverse());
    sb.insert(5, "college");
    sb.deleteCharAt(3);
    sb.delete(1, 3);
    System.out.println(sb);
	
Example :-
-----------
	StringBuilder sb = new StringBuilder("sahyog");
	System.out.println(sb.charAt(2));
	sb.append(" ");
	sb.append("colleglle");
	System.out.println(sb);
	System.out.println(sb.length());
	System.out.println(sb.equals(sb));
	System.out.println(sb.indexOf("o"));
	System.out.println(sb.hashCode());
	System.out.println(sb.deleteCharAt(10));
	System.out.println(sb.insert(10, "abc"));
	System.out.println(sb.subSequence(2,10));
	System.out.println(sb.getClass());
	sb.ensureCapacity(10);
	System.out.println(sb.capacity());
	sb.setLength(4);
	System.out.println(sb);
 
StringBuilder( non - synchonized ) (1.5 v )
--------------------------

Topic for the projects :-(core java) // Standalone /Desktop application(Swing/applet)
--------------------------------------
1)Library management system 
2)College management system 
3)Games (snake and ladder , Tic Tac Toe)
4)Airline reservation system
5)stock management system
6)hacking of wifi using java 
7)Chatting Applications 


On 27th Nov u all need to submit ur name and the group and the topics.
 
 OOPs : -
 --------------
Object Oriented Programming lang :-
----------------------------------------
1)Class/Object
2)Inheritance 
3)Polymorphism
4)Encapsulation
5)Abstraction/Interface 

Class :
-------
It is template.class is blue print 
class Demo
{


}

Inheritance :-
------------------
single inheritance       
Multiple inheritance  
Multilevel inheritance
Hybrid inheritance
cyclic inheritance

polymorphism :-
-----------------
Poly + Morphism ===> many  + forms   one thing many forms
                                     -----------------------
Overloading                          add(int a , int b)
Overriding                           add(10,20)
                                     add(int a , int b , int c )
                                     add(10,20,30)
									 add(int a , int b , int c , int d )
									 add(10,20,30,40)
 
 
 
Overloading :-
--------------
Q:>When a method is said to be overloaded ? 
when both methods have same name and different argument .
 Example : m1(int x )
           m1(float y)
		   
case 1:here If we are passing the char argument it will print int - arg
------ because compiler promotes the char - argument to the next level
class Demo
{
	
 public void m1(int i)
 {
	 System.out.println("int - arg");
 }
public void m1(float f)
{
    System.out.println(" this is float - arg ");	
}
public static void main(String[] args) {
	Demo d = new Demo();
	d.m1(10.5f);//this is float - arg 
	d.m1(10);//int - arg
	d.m1('a');//int - arg
}
		   
case 1 : 
-----------
class Demo
{
   void m1(int... x)//in which version : 1.5
   {
	   System.out.println(" var - arg argument");
   }
   void m1(int x , int y)//in which version :1.0
   {
	   System.out.println("integer- integer argument");
   }
  void m1(int x )
  {
	  System.out.println("integer argument ");
  }
  public static void main(String[] args) {
	Demo d = new Demo();
	d.m1(10,10);//
	d.m1(10);//
	d.m1(10,10,10);//
}
}
Case ll:
-----------
class Demo
{
  void m1(Object o)
  {
	  System.out.println(" this is Object class");
  }
  void m1(String s)
  {
	  System.out.println(" this is string class");
  }
  public static void main(String[] args) {
	Demo d = new Demo();
	//d.m1(new Object());//this is Object class
	//d.m1("abc" );//this is string class
	//d.m1(null);//
}
}
Case 3 : 
--------
class Demo
{
  void m1(StringBuffer sb)
  {
	  System.out.println(" this is String- Buffer  class");
  }
  void m1(String s)
  {
	  System.out.println(" this is string class");
  }
  public static void main(String[] args) {
	Demo d = new Demo();
	//d.m1(new Object());//this is Object class
	//d.m1("abc" );//this is string class
	d.m1(null);//
}


Overriding :-
-----------------
If child class is not happy with the parent class method then child class 
is aloowed to redefine that method again based on its own requirment.This 
process is known as overriding concept . 
 
 
 Polymorphism is of two type :
 ---------------------------------
 1)compile time polymorphism (Overloading) always it is going to check the reference 
 2)run time polymorphism     (Overriding ) always it is going to check the Object
 
Example : -
------------
class Parent
{
  void marry( )
  {
	  System.out.println("esha");
  }
}
class Demo extends Parent
{
   void marry()
   {
	   System.out.println("rita");
   }
   public static void main(String[] args) {
	
	   Parent pc = new Demo();//reference=Parent    object=Demo
	   pc.marry(10);//rita
	
}
}
Rules for overriding :-
------------------------
Rule 1 :
---------
In overriding the method name and argument type must be same .
example :
---------
class Parent
{
  void marry( )
  {
	  System.out.println("esha");
  }
}
class Demo extends Parent
{
   void marry()
   {
	   System.out.println("rita");
   }
   public static void main(String[] args) {
	
	   Parent pc = new Demo();//reference=Parent    object=Demo
	   pc.marry(10);//rita
 
 Rule 2 :
 ---------
 In Overriding the return type must be same but this rule is applicable till java 1.4v.
 From java 1.5v onwards we can take covarient return types.
 
Example : 
-----------

class Parent
{
 public  Number m1(int a , int b)
   {
	  System.out.println("parent");
	  return a+b;
	  
   }

}
public class Child extends Parent {
	
	public Number m1(int a , int b)
	{
		System.out.println("child");
		return a*b;
		
	}
	public static void main(String[] args) {
	
	 Parent pc = new Child();
	 System.out.println(pc.m1(10,20));
	}

}
Example 2:-
--------------
class Parent
{
 public Object  m1(String a , String b)
   {
	  System.out.println("parent");
	  return a+b;
	  
   }

}
public class Child extends Parent {
	
	public String m1(String a , String b)
	{
		System.out.println("child");
		return b;
		
		
	}
	public static void main(String[] args) {
	
	 Parent pc = new Child();
	 System.out.println(pc.m1("abc","def"));
	}

}

Rule 3 :-
------------
If we are doing the method as private it can be accessed only within the same class 
not out side the class .
So, private modifier don't participate in the overriding concept .

Example : 
-----------

class Parent
{
 String  m1(String a , String b)
   {
	  System.out.println("parent");
	  return b;
	  
   }

}
public class Child  {
	
	private String m1(String a , String b)
	{
		System.out.println("child");
		return b;
		
		
	}
	public static void main(String[] args) {
	
	// Parent pc = new Child();
	 Parent p = new Parent();
	 Child c = new Child();
	 System.out.println(c.m1("abc","lmn"));
	// System.out.println(pc.m1("abc","def"));
	}

}
 
Rule 4: -
----------
Final is a modifier which can be applied with class , methods and variables .
So,once i am defining the method as final we cannot override that method .
Example :-
-------------
class Parent
{
 public final Object  m1(String a , String b)  // not allowed 
   {
	  System.out.println("parent");
	  return a+b;
	  
   }

}
public class Child extends Parent {
	
	public String m1(String a , String b)
	{
		System.out.println("child");
		return b;
		
		
	}
	public static void main(String[] args) {
	
	 Parent pc = new Child();
	 System.out.println(pc.m1("abc","def"));
	}

}
Example 2 :-
------------
class Parent
{
 public  Object  m1(String a , String b)
   {
	  System.out.println("parent");
	  return a+b;
	  
   }

}
public class Child extends Parent {
	
	public final String m1(String a , String b) // this is allowed 
	{
		System.out.println("child");
		return b;
		
		
	}
	public static void main(String[] args) {
	
	 Parent pc = new Child();
	 System.out.println(pc.m1("abc","def"));
	}

}

Rule 5 :-
-------------
int     ==> Integer
float   ==>Float
double  ==>Double
long    ==>Long
byte    ==>Byte

Abstraction :--
-------------------
abstract keyword is used to define the Abstraction.
abstract keyword we can define with class and method .
If we are defining the class as an abstact then we are 
not allowed to create the object for that class .
In abstact class we can have abstract as well as not abstract methods .
Example :-
------------
abstract class Sybcafirstprog {
   
	abstract void m1();
	 void m2()
	{
		System.out.println("hello");
	}
	public static void main(String[] args) {
		Sybcafirstprog s ;
		//s.m1();
		
	}
	}

If we are defining the method as an abstract then we should terminate it with ";".
means the abstract methods doesnt contain the body part .
so child class is responsible for providing the body for the abstract methods. 
 
Example 2 :-
---------------
abstract class AbsDemo
{
   void m1()
   {
	   System.out.println(" this is no abstract method");
   }
   abstract void m2();
   abstract void m3();
}
class Demo extends  AbsDemo
{
	void m2()
	{
		System.out.println("hello this is abstract method m2");
	}
	void m3()
	{
		System.out.println("thisi s m3 method ");
	}
	
public static void main(String[] args) {
	Demo d = new Demo();
	d.m2();
	d.m1();
	d.m3();
	
}
	}
 
====================================
 
abstract class AbsDemo
{
   void m1()
   {
	   System.out.println(" this is no abstract method");
   }
   abstract void m2();
   abstract void m3();
   abstract void m4();
   abstract void m5();
   abstract void m6();
   abstract void m7();
   abstract void m8();
   abstract void m9();
   abstract void m10();
   abstract void m11();
   abstract void m12();
   .
   .
   .
   .
   .
   .
   .
   .
   .
   .
   abstract void m100();
   abstract void m101();
   abstract void m102();
   abstract void m103();
   abstract void m104();
   
}
class demo extends AbsDemo
{
  
   104

}
class Demo1 extends AbsDemo
{
  104
}
Interface :-
--------------
To design the interface we are using the interface keyword .
It is pure abstract class .
Example :-
-------------
interface DemoDD
{
  	void m1();
  
    abstract void m2();
    abstract void m3();
}
class Demo implements DemoDD
{

	@Override
	public void m1() {
		// TODO Auto-generated method stub
		System.out.println("this is m1 method");
	}

	@Override
	public void m2() {
		// TODO Auto-generated method stub
		System.out.println("this is m2 method");
	}

	@Override
	public void m3() {
		// TODO Auto-generated method stub
		System.out.println("thisi is m3 methods ");
	}
	public static void main(String[] args) {
		Demo d = new Demo();
		d.m1();
		d.m2();
		d.m3();
	}
	
	}
 
interface variables :-
---------------------------
Interface can contain the variables.
every interface variable is by default public static final
 
why public ?
--------------
to make this variable visible for the other classes.

why static ?
-------------
without existing object implementing class can access this variable.

why final ?
------------------
if one implementation class changes the value then remaining other classes
will be affected . so to restrict this we are using final keyword .
 
Multiple interface can be implemented but multiple class cannot be extended.
 
example :-
------------
package abhi;
class Sum
{}
interface inter
{
	 void m1();
}
interface inter1
{
	void m1();
}

public class Abhishek extends Sum implements  inter ,inter1 {
      public void m1()
      {}
   public static void main(String[] args) {
       Abhishek ab = new Abhishek();
       ab.m1();
}
}
Example 2 :-
----------
package abhi;
class Sum
{}
interface inter
{
	int x= 10;
	 void m1();
}
interface inter1
{
	int x = 20;
	void m1();
}

public class Abhishek extends Sum implements  inter ,inter1 {
      public void m1()
      {}
     
   public static void main(String[] args) {
       Abhishek ab = new Abhishek();
       System.out.println(inter.x);//
       System.out.println(inter1.x);
       ab.m1();
}
}

Marker Interface :--
------------------------
If an interface doesnt contain any method then it is known as marker interface .
Jvm is going to provide the ability for this marker interface .
Example : cloneable,serilizable interfaces.

Is it possible to create our own marker interface ?
------------------------------------------------------
yes , but for this we need to make customized jvm.

Adapter classes :-
----------------------
Adapter class is a simple java class that implements an interface with only empty
implementation.

Example :-
------------------
package abhi;

interface x
{
   void m1();
   void m2();
   void m3();
   void m4();  
}
abstract class Adapter implements x
{
   public void m1()
   {}
   public void m2()
   {}
   public void m3()
   {}
   public void m4()
   {}
}
class Test extends Adapter 
{
    public void m1()
    {
    	System.out.println("hello this is m1() of test class");
    }

}
class Abhishek extends Test
{
    public void m2()
    {
    	System.out.println("thisa is m2 method");
    }
   public static void main(String[] args) {
	
	   Abhishek ab = new Abhishek();
	   ab.m2();
	   ab.m1();
}
}
Difference between Abstraction and interface :-
---------------------------------------------------

               Interface                                           Abstraction 
			-------------------                              -----------------------
	 
	 1)If we dont know about implementation and just     If we talking about implementation 
	   we have some requirement specification then we    but not complete then go for abstract class.
	   should go for the interface .           

     2)Every variables should be final ,static ,public   There is no restriction on abstract class variables .

     3)Every method inside the interface is              There is no restriction on abstract class methods  .
	   public and abstract and we cant provide any 
	   other modifier.
	   
     4)Inside interface we cant declare static           we can define static and instance block .
       and instance block
     5)Inside interface we cant declare the              yes we can declare the constructor inside the 
	   constructor.                                                  abstract class .
	   

Packages :-
-----------
there are all together two types of import statement :-
1)Explicit import
2)Implicit import 

Explicit import :-
---------------
import java.util.ArrayList;
It is highly recommended to use explicit import because it improves the performance and 
readability of the code .

Implicit import :-
-------------------
import java.util.*;
this is not a recommended approach it reduces the readability of the code .
and performance is impacted.

Another way to import 
---------------------------

class Parent extends abhi.Abhi2
{
public  Object m1(String a , String b)
   {
	  System.out.println("parent");
	return b;
	  
   }
whenever we are using fully qualified name it is not required to use the import statement.
													                                 																																																																																																																																																																																																																																															
Static import :-
-----------------
Without static import 
-----------------------
Example :-
-----------
class Child
{
	
public static void main(String[] args) {
	System.out.println(Math.sqrt(4));
	System.out.println(Math.max(10, 20));
}
}

with static import :-
-------------------------
import static java.lang.Math.*;
class Child extends abhi.Abhi2
{
public static void main(String[] args) {
	System.out.println("this is sqrt" + sqrt(4));
	System.out.println("this is max value" +max(10, 20));
	System.out.println("this is min value" +min(10, 20));
}
}

Exaception Handling :-
-----------------------
MEthods to print the exception object
-----------------------------------------
example :
---------
		try
		{
			System.out.println(10/0);
		}
		catch(Exception e)
		{   e.printStackTrace();
			System.out.println(e);
			System.out.println();
			e.getMessage();
			}
			
Case 1:
------
public class New_Demo {
	public static void main(String[] args)
	{
		System.out.println(10/0);

	}

}
in this case ,main() is responsible to create exception object 
and handover to the JVM

Case II:
-----------
public class New_Demo {
	public static void main(String[] args)
	{
		throw new ArithmeticException("divide by zero");

	}
In this case programmer is responsible in creating the exception object
explicity and handover to the JVM manually.

Case III:
-----------
try
        {
			System.out.println(10/0);
		}
       catch(Exception e)
		{
    	   System.out.println("npe");
		}
       catch(ArithmeticException a)
		{
    	   System.out.println("exp");
		}
		
Here we are going to get the error because parent to child relationship 
is not allowed .
but we can go through the child to parent relationship.

Customized Exception :
------------------------
sometimes to meet our programming requirement we can define our own 
exception or we can say customized exception .

How to define :-
-------------------
public class New_Demo extends Exception
{
	public New_Demo(String s ) 
	{
	super(s);		
	}

Swing :-
-----------
Swing is part of java foundation classes(JFC) that is used to create window-based application.
Java swing api is found in javax.swing package .

To create a frame :-
----------------------
*By creating the object of Frame class
*By extending frame class

 
Example :-
--------------
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;

public class First_SwingApp {

	public static void main(String[] args) {
		
		JFrame j = new JFrame();
		JButton b1 = new JButton("add");
		JButton b2 = new JButton("subtract");
		JButton b3 = new JButton("Multiply");
		JComboBox c = new JComboBox();
		c.setBounds(140, 140, 88,40);
		b1.setBounds(0,120,80,30);
		j.add(c);
		j.add(b1);
		j.setSize(600,600);
		j.setLayout(null);
		j.setVisible(true);
		System.out.println("frame is visible");
		
		
	}
}

Example 2:-
--------------
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JTextArea;
import javax.swing.JTextField;

public class First_SwingApp {

	public static void main(String[] args) {
		
		JFrame j = new JFrame("Button Action");
		JTextField tf= new JTextField();
		JTextArea ta = new JTextArea();
		ta.setBounds(100,140,200,40);
		tf.setBounds(50,50,150,20);
		JButton b = new JButton(new ImageIcon("C:/Users/LENOVO/Desktop/button imae.jfif"));
		b.setBounds(50,100,200,300);
		b.addActionListener(new ActionListener() {
			
			@Override
			public void actionPerformed(ActionEvent e) {
				ta.setText("welcome u have sucessfully logged in" );
				
				
			}
		});
		
		j.add(ta);
		j.add(b);
		j.add(tf);
		j.setSize(600,600);
		j.setLayout(null);
		j.setVisible(true);
		System.out.println("frame is visible");
		
		
	}
}
Example 3:-
------------
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JTextArea;
import javax.swing.JTextField;

public class First_SwingApp {

	public static void main(String[] args) {
		
		JFrame j = new JFrame("Button Action");
		JTextField tf= new JTextField();
		JTextArea ta = new JTextArea();
		ta.setBounds(100,140,200,40);
		tf.setBounds(50,50,150,20);
		JButton b = new JButton("find ip");
		b.setBounds(50,100,80,30);
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			try
			{
				String host = tf.getText();
			 String ip=java.net.InetAddress.getByName(host).getHostAddress();
			 ta.setText("ip of " +host+ " is " + ip);
			}
			catch(Exception ex)
			{
				System.out.println(ex);
			}
				
			}
		});
		
		j.add(ta);
		j.add(b);
		j.add(tf);
		j.setSize(600,600);
		j.setLayout(null);
		j.setVisible(true);
		System.out.println("frame is visible");
		
		
	}
}
Desiging the calculator App :-
------------------------------
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

class Calculate implements ActionListener{
   JTextField tf1,tf2,tf3;
   JButton b1,b2;
   public Calculate() {
	JFrame f = new JFrame();
	tf1=new JTextField();
	tf1.setBounds(50,50,100,30);
	tf2=new JTextField();
	tf2.setBounds(50,100,100,30);
	tf3=new JTextField();
	tf3.setBounds(50,150,100,30);
	b1=new JButton("add");
	b1.setBounds(50,200,80,30);
	b2=new JButton("sub");
	b2.setBounds(140,200,80,30);
	b1.addActionListener(this);
	b2.addActionListener(this);
	f.add(tf1);
	f.add(tf2);
	f.add(tf3);
	f.add(b1);
	f.add(b2);
	f.setSize(400,300);
	f.setLayout(null);
	f.setVisible(true);
   }
	
   public void actionPerformed(ActionEvent e)
   {
	   String s1 = tf1.getText();
	   String s2 = tf2.getText();
	   int a = Integer.parseInt(s1);
	   int b = Integer.parseInt(s2);
	   int c = 0;
	   if (e.getSource()==b1)
	   {
		   c=a+b;
	   }
	   else if (e.getSource()==b2)
	   {
		   c=a-b;
	   }
	   
	   String result=String.valueOf(c);
	   tf3.setText(result);  
   }
	public static void main(String[] args) {
		new Calculate();
	}
}
   
example for checkbox :-
-----------------------
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;

public class CheckBox_Swing extends JFrame implements ActionListener
{
    JLabel jl;
    JCheckBox cb1,cb2,cb3;
    JButton jb;
    public CheckBox_Swing() {
    	JLabel j2;
    	j2=new JLabel();
		jl= new JLabel("Welcome to KFC");
		jl.setBounds(50,50,330,30);
		jl.setFont(new Font("helvetica", Font.BOLD, 20));
		cb1=new JCheckBox("Chicken leg");
		cb1.setBounds(100,100,150,20);
		cb2=new JCheckBox("chicken Burger");
		cb2.setBounds(100,150,150,20);
		cb3= new JCheckBox("fries");
		cb3.setBounds(100,200,150,20);
		jb= new JButton("order");
		jb.setBounds(100,250,80,30);
	
		jb.addActionListener(this);
		add(jl);
		add(cb1);
		add(cb2);
		add(cb3);
		add(jb);
		setSize(500,400);
		setLayout(null);
		setVisible(true);
    }
    @Override
    public void actionPerformed(ActionEvent e) {
    	int amount=0;
    	String mg="";
    	if(cb1.isSelected()) {
    		amount +=200;
    		mg="chicken leg : 200 \n ";
    	}
    	if(cb2.isSelected()) {
    		amount +=100;
    		mg="chicken Burger : 100 \n ";
    	}
    	if(cb3.isSelected()) {
    		amount +=50;
    		mg="chicken fries : 50 \n ";
    	}
    	mg +="-------------\n";
    	
    JOptionPane.showMessageDialog(this,mg +"Total Amount is : " + amount);
    }
    public static void main(String[] args) {
		new CheckBox_Swing();
	}
	}
	
pattern program :-
----------------------
Program 1 :-
--------------------
1 1 1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2 2 2
3 3 3 3 3 3 3 3 3 3
4 4 4 4 4 4 4 4 4 4
5 5 5 5 5 5 5 5 5 5
6 6 6 6 6 6 6 6 6 6
7 7 7 7 7 7 7 7 7 7
8 8 8 8 8 8 8 8 8 8
9 9 9 9 9 9 9 9 9 9
10 10 10 10 10 10 10 10 10 10

program:-
----------
Scanner sc = new Scanner(System.in);
	System.out.println("enter some no: ");
	int n = sc.nextInt();
	
	for (int i =1;i<=n;i++)
	{
		for (int j=1 ; j<=n;j++)
		{
			System.out.print(i);
		}
		System.out.println();
		
    
program 2:-
-----------------
10 10 10 10 10 10 10 10 10 10
9 9 9 9 9 9 9 9 9 9
8 8 8 8 8 8 8 8 8 8
7 7 7 7 7 7 7 7 7 7
6 6 6 6 6 6 6 6 6 6
5 5 5 5 5 5 5 5 5 5
4 4 4 4 4 4 4 4 4 4
3 3 3 3 3 3 3 3 3 3
2 2 2 2 2 2 2 2 2 2
1 1 1 1 1 1 1 1 1 1

1) n=int(input("Enter the number of rows: "))
2) for i in range(1,n+1):
3) for j in range(1,n+1):
4) print(n+1-i,end=" ")
5) print() 

1
2 2
3 3 3
4 4 4 4
5 5 5 5 5
6 6 6 6 6 6
7 7 7 7 7 7 7
8 8 8 8 8 8 8 8
9 9 9 9 9 9 9 9 9
10 10 10 10 10 10 10 10 10 10

solution :-
-------------
	Scanner sc = new Scanner(System.in);
	System.out.println("enter some no: ");
	int n = sc.nextInt();
	
	for (int i =1;i<=n;i++)
	{
		for (int j=1 ; j<=i;j++)
		{
			System.out.print(i);
		}
		System.out.println();
	}
}

n=int(input("Enter the number of rows: "))
2) for i in range(1,n+1):
3) for j in range(1,i+1):
4) print(i,end=" ")
5) print() 	

Multi-Threading in java :-
----------------------------
* Multithreading in Java is a process of executing multiple threads simultaneously.
* A thread is a lightweight sub-process, the smallest unit of processing.
* Multiprocessing and multithreading, both are used to achieve multitasking.
 
Multitasking :-
--------------
Multitasking is a process of executing multiple tasks simultaneously.

Multitasking can be achieved in two ways:-
----------------------------------------------
1)Process-based Multitasking (Multiprocessing)
2)Thread-based Multitasking (Multithreading)

Thread-Based :-
------------------
Executing several task simultaniusly where each task is a seperate independent
part of the same program.

The main purpose of multi-tasking is to increase the performance by reducing the response time
of the processor.

The main application of multi-threading is in the area of :-
-------------------------------------------------------------------
1)To develop multimedia and graphics
2)To develop animation
3)To develop games


There are two ways to create a thread:
---------------------------------------
1)By extending Thread class
2)By implementing Runnable interface.

NOTE : whatever you write inside the run() method that is the task of the Thread.

Example by using Thread class :-
---------------------------------
class Thread_Demo extends Thread{  
public void run()
{  
System.out.println("thread in running mode");  
}  
public static void main(String args[])
{  
Thread_Demo t=new Thread_Demo();  
t.start();  
 }  
}  
Example by using Runnable interface :-
----------------------------------------
class Thread_Demo implements Runnable{  
public void run()
{  
System.out.println("thread in running mode");  
}  
  
public static void main(String args[]){  
Thread_Demo r=new Thread_Demo();  
Thread t =new Thread(r);  
t.start();  
 }  
} 

Sleep method Example :-
-----------------------

import java.io.Serializable;

public class Ex_using_thread extends Thread
{
	public void m1()
	{
		System.out.println("this is m1()");
	}
	public void run()
	{
		for(int i=0;i<10;i++)
		{  
			try {
			Thread.sleep(1000);
		}
		catch(InterruptedException e)
		{
			System.out.println(e);
		}
		System.out.println(i);
		}
		
	}

	public static void main(String[] args) {
		Ex_using_thread t = new Ex_using_thread();
		Ex_using_thread t1 = new Ex_using_thread();
		Ex_using_thread t2 = new Ex_using_thread();
		Ex_using_thread t3 = new Ex_using_thread();
		
		t1.start();//0,1,
		t2.start();
		//t.m1();

	}

}

join method :-
----------------
* Join() causes the currently running threads to stop executing until 
  the thread it joins with completes its task.
* It always throws InteruptedException so we must need to handle it.

Example :-
-----------
public class Ex_using_thread extends Thread
{
	public void m1()
	{
		System.out.println("this is m1()");
	}
	public void run()
	{
		for(int i=0;i<10;i++)
		{  
			try {
			Thread.sleep(1000);
		}
		catch(InterruptedException e)
		{
			System.out.println(e);
		}
		System.out.println(i);
		}
		
	}
    public static void main(String[] args) {
		Ex_using_thread t = new Ex_using_thread();
		Ex_using_thread t1 = new Ex_using_thread();
		Ex_using_thread t2 = new Ex_using_thread();
		Ex_using_thread t3 = new Ex_using_thread();
		t.start();
		try
		{
			t.join(1000);
			
		}
		catch (Exception e) {
			System.out.println(e);
		}
		t2.start();
		t3.start();
		

Thread Method example (getName,setName):-
-----------------------------------------
public class Thread_Method extends Thread {
	public void run()
	{
		System.out.println("Thread in running mode ");
	}
	public static void main(String[] args) {
		Thread_Method t= new Thread_Method();
		Thread_Method t1 = new Thread_Method();
		System.out.println("Name of the thread is : "+t.getName());
		System.out.println("Name of the thread is : "+t1.getName());
		t.start();
		t1.start();
		t.setName("java thread-1");
		System.out.println("after changing the thread name: "+t.getName());
		
				
	}

}
Thread Priority :-
----------------------
*  Priorities are represented by a number between 1 and 10.
*  But it is not guaranteed because it depends on JVM specification that which scheduling it chooses.
*  Default priority of a thread is 5 (NORM_PRIORITY).
*  The value of MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10.
*  Three priority given by java :
        1) public static int MIN_PRIORITY
        2) public static int NORM_PRIORITY
        3) public static int MAX_PRIORITY

Example :-
-------------
public class Thread_Priority extends Thread{
	public void run()
	{
		System.out.println("thread name:"+Thread.currentThread().getName());
		System.out.println("thread priority:"+Thread.currentThread().getPriority());
	}

	public static void main(String[] args) {
		Thread_Priority t= new Thread_Priority();
		Thread_Priority t1= new Thread_Priority();
		Thread_Priority t2= new Thread_Priority();
		t.setPriority(MIN_PRIORITY);
		t1.setPriority(MAX_PRIORITY);
		t2.setPriority(NORM_PRIORITY);
		t.start();
		t1.start();
		t2.start();	
	}
}

Daemon Thread :-
----------------
* It provides services to user threads for background supporting tasks. 
* Its role is to serve user threads.
* Its life depends on user threads.
* It is a low priority thread.

Example :-
---------------

public class Demon_Thread extends Thread {
    public void run()
    {
        if(Thread.currentThread().isDaemon())	
        {
        	System.out.println("this is demon thread");
        }
        else
        {
        	System.out.println("user thread");
        }
    }
	public static void main(String[] args) {
		Demon_Thread d = new Demon_Thread();
		Demon_Thread d1 = new Demon_Thread();
		Demon_Thread d2 = new Demon_Thread();
		d.setDaemon(true);
		d.start();
		d1.start();
		d2.start();
		
	}

}

Inter - Thread communation :-
------------------------------
It it like allowing the Synchronized thread to communicate with each other.
In order to apply this we are going to use the Object class methods .
1)wait()
2)notify()
3)notifyAll()

wait() method :-
---------------
i)wait() throws InteruptedException
ii)wait(long milisec) throws InteruptedException
lock

int a[]={10,20,30,10.5,"str"};
Integer i = new Integer();



Java I/O :-
----------------
stream : Sequence of data 

Stream are create automatically :--
1)System.out : standard outstream
2)System.in  : Standard input stream
3)System.err : Standard error stream

OutputStream : It is an abstract class . 

Methods of outputStream :-
-----------------------------
1)public void write(int) throws IOExeption
2)public void write(byte[]) throws IOExeption
3)public void flush() throws IOExeption
4)public void close throws IOExeption

InputStream : It is an abstract class . 

Methods of InputStream :-
-----------------------------
1)public abstract int read() throws IOExeption

2)public int available() throws IOExeption
4)public void close throws IOExeption

FileOutputStream :-
------------------------
Example :-
---------------
import java.io.*;
public class FileOutputStreamExample {
public static void main(String[] args) {
	try {
		FileOutputStream fos= new FileOutputStream("C:/Users/navne/Desktop/javafiles/test.txt");
		String s= "Data written through the Outputstatement";
		byte b[]=s.getBytes();
		fos.write(b);
		fos.close();
		System.out.println("Data written sucessfully");
	}
	catch(Exception e)
	{
		System.out.println(e);
	}
}
}

FileInputStream :-
----------------------
Example :
----------
import java.io.*;
public class FileInputStreamExample {
public static void main(String[] args) {
	try
	{
		FileInputStream fis=new FileInputStream("C:/Users/navne/Desktop/javafiles/test.txt");
		int i = fis.read();
		System.out.println((char)i);
		fis.close();
	}
    catch(Exception e )
	{
    	System.out.println(e);
	}
}
}
Example 2:-
---------------
import java.io.*;
public class FileInputStreamExample {
public static void main(String[] args) {
	try
	{
		FileInputStream fis=new FileInputStream("C:/Users/navne/Desktop/javafiles/test.txt");
		int i = 0;
		while ((i=fis.read())!=-1)
		{
		System.out.print((char)i);
		}
		fis.close();
	}
    catch(Exception e )
	{
    	System.out.println(e);
	}
}
}

BufferOutputStream :-
-----------------------
This class is used for the buffering an output stream.
It internally uses buffer to store the data .

Example 1 :-
------------
import java.io.*;

public class BufferOutputStream_Demo {
	public static void main(String[] args) {
		
	
	try {
		FileOutputStream fos= new FileOutputStream("C:/Users/navne/Desktop/javafiles/test.txt");
		BufferedOutputStream bos=new BufferedOutputStream(fos);
		String s= "Data written through the Buffer Outputstatement";
		byte b[]=s.getBytes();
		bos.write(b);
		bos.close();
		System.out.println("Data written");
	}
	catch(Exception e)
	{
		System.out.println(e);
	}
}
}
Exmple 2:-
--------------
import java.io.*;

public class BufferInputstatement_Demo {
	public static void main(String[] args) {
		try
		{
			FileInputStream fis=new FileInputStream("io.txt");
			BufferedInputStream bis= new BufferedInputStream(fis);
			int i = 0;
			while ((i=bis.read())!=-1)
			{
			System.out.print((char)i);
			}
			bis.close();
		}
	    catch(Exception e )
		{
	    	System.out.println(e);

		}
	}
	}

Serialization :-
---------------------
Serializable is an interface present in java.io package.
This interface doesnt contain any method so it is kwn as Marker interface.
Marker Interface ==> the interfce which which doesnt contain any method. 
The ability to this interface is provided by the JVM.

The process of saving the state of the object into the file or
we can say it is a process of converting object from java supported
form to text/network supported form .
 
Deserialization :
 --------------------
The process of converting  object from the file or
we can say it is a process of converting object from nwetwork supported form
to java supported form .

By using 2 stream we can achieve serilization :
1)FileOutputStream
2)ObjectOutputStream

By using 2 stream we can achieve de-serilization :
1)FileInputStream
2)ObjectInputStream

Example :
-----------
package serial;

import java.io.*;
class Test implements Serializable
{
	 //static final long serialVersionUID=1L;
    transient  int i = 10;
     transient  int j = 20;
}
public class Serialization  {
    
	public static void main(String[] args)throws Exception
	{
		Test t = new Test();
		FileOutputStream fos = new  FileOutputStream("abc.txt");
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		oos.writeObject(t);
		System.out.println("data gone into the file ");
		FileInputStream fis = new FileInputStream("abc.txt");
		ObjectInputStream ois = new ObjectInputStream(fis);
		System.out.println("working");
	    Test t1= (Test)ois.readObject();
	    System.out.println("working 2 ");
	    System.out.println(t1.i +"..."+t1.j);
	}
	
}


Transient :-
----------------
It is modifier which can be applied only with the variables.

abc@123 ===>000000011110010010010100100011111
weabc@123ke  ===> 0001111011010101001

Example of transient :-
-----------------------------
package serial;
import java.io.*;
import java.util.*;
class cust_Account implements Serializable
{
   String username="navneet"	;
   transient String pwd="abc@123";
  private void  writeObject(ObjectOutputStream os)throws Exception
  {
	  os.defaultWriteObject();
	  String newpwd="wehave"+pwd;//wehaveabc@123
	  os.writeObject(newpwd);  
  }
 private void readObject(ObjectInputStream is)throws Exception
 {
	 is.defaultReadObject();
	 String newpwd=(String)is.readObject();
	 pwd=newpwd.substring(6);//abc@123
	 
 }
}
public class Banking_App {
    public static void main(String[] args)throws Exception {
    	cust_Account a= new cust_Account();
    	System.out.println(a.username +"   "+a.pwd);
    
   FileOutputStream fos= new FileOutputStream("account.txt");
   ObjectOutputStream oos = new ObjectOutputStream(fos);
   oos.writeObject(a);
   FileInputStream fis = new FileInputStream("account.txt");
   ObjectInputStream ois= new ObjectInputStream(fis);
   cust_Account a1=(cust_Account)ois.readObject();
   System.out.println(a1.username +"   "+a1.pwd);   	
	}
}

Inner class :-
----------------
Inside the class we can write another class
syntax :
----------
class Outer
{
class inner
{}
}
The main advantage of inner class is :
------------------------------------------
*It can access all tthe member of outer class including the private members.
*Readability of the code increases.
*less code is required to write.

Example :
--------------
public class Example_1 {
private	int a= 100;

class Inner
{
     void m1()
     {
    	System.out.println("a value is :"+a); 
     }
}
public static void main(String[] args) {
	Example_1 e = new  Example_1();
	Example_1.Inner in=e.new Inner();
	in.m1();
}
}

Java Mail Api :-
----------------------
The JavaMail is an API that is used to compose, write and read electronic messages (emails).

The JavaMail API provides protocol-independent and plateform-independent framework for sending 
and receiving mails.

The javax.mail and javax.mail.activation packages contains the core classes of JavaMail API.

There are some protocols that are used in JavaMail API :-
----------------------------------------------------------------
SMTP : SMTP is an acronym for Simple Mail Transfer Protocol. 
       It provides a mechanism to deliver the email.
POP  : POP is an acronym for Post Office Protocol, also known as POP3. 
       It provides a mechanism to receive the email.
MIME : Multiple Internet Mail Extension (MIME) tells the browser what 
       is being sent e.g. attachment, format of the messages etc.


collection framework :-
------------------------------
if we want to represent the group of object as a single entity then we should go for the 
collection framework.
Collection is an interface .
11 methods are there in this interface .

list, set , queue ==> interfaces in the collection.

ArrayList :-
--------------------
int a []={10,20,"abc"}

ArrayList al = new ArrayList();
al.add(10);
al.add(10.5)
al.add("abc")



Example :
the electricity board charges from there customer a/c to unit consumed per month.
tariff:
  upto 100 unit = rs 5 per unit                
  for next 200 unit = rs 6 per unit          
  then cal the total bill if unit is 210.

solution : 

int unit=210;
		int amount;
    if(unit<=100)
    {
    	amount=5*unit;
    	System.out.println(amount);
    }
    if((unit>100)&&(unit<300))
    		{
    	      amount=100*5+(unit-100)*6;
    	      System.out.println(amount);
    		}
	}

Wap to determine the taxi fare from the customer on the distance travelled as per
 the traffic  given below :

       Distance Travelled             fare
      ----------------------         ---------
       upto 10 km                    fixed charge Rs80
       11 to 20 km                   Rs 6/km
       21 to 30 km                   Rs 5/km
       31 and Above                  Rs 4/Km

Calculate the fare to be paid .



Shift operator :-
----------------------
sop(10>>2) # 

0101


















 